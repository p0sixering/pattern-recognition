<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<script type="text/javascript" src="raphael-min.js"></script>
<script type="text/javascript" src="shapes.js"></script>
</head>

<body>
<script type="text/javascript">


// From http://stackoverflow.com/questions/321113/
function partial(func /*, 0..n args */) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var allArguments = args.concat(Array.prototype.slice.call(arguments));
    return func.apply(this, allArguments);
  };
}


// Click functions
// append with:  circle.click(clickFunction);
function testClick() {
    console.log("click");
}

function basicNoteClick(audioContext, freq) {
    var oscillator = audioContext.createOscillator(); // Oscillator defaults to sine wave
    oscillator.frequency.value = freq;
    var vca = audioContext.createGain();
    vca.gain.value = 0;
    oscillator.connect(vca);
    vca.connect(audioContext.destination)
    oscillator.start(0);
    vca.gain.value = 0.5;
    setTimeout(function(){vca.gain.value = 0; vca.disconnect(); oscillator.disconnect()}, 500);
}

var allSizes = ['tiny', 'small', 'medium', 'large', 'huge', 'gigantic'];
var buttonData = [];
var butttonDifferences = {};

// I am missing 'area' / any way to disambiguate rectangles
// For rects and ellipses, I should take the larger of the two dimensions
// I should also compute area, dammit

function getSides(buttonShape) {
    var sides;
    if (buttonShape == 'circle') {
        sides = 0;
    } else if (buttonShape == 'triangle') {
        sides = 3;
    } else if (buttonShape == 'pentagon') {
        sides = 5;
    } else if (buttonShape == 'hexagon') {
        sides = 6;
    } else if (buttonShape == 'octagon') {
        sides = 8;
    } else {
        sides = 4;
    }
    return sides;
}

function addButton(b, location, color, shape, radius) {
    // Calculate brightness
    red = parseInt(color.substring(1, 3), 16);
    green = parseInt(color.substring(3, 5), 16);
    blue = parseInt(color.substring(5, 7), 16);
    brightness = red + green + blue / 3;

    // Get side count
    var sides = getSides(shape);

    // I am sure there is a cute way to get this programmaticaly, but I won't sweat it for now
    // also I need to sort out "radius" for rectangles
    radius = radius.x;
    var size;
    if (radius < 8) {
        size = 'tiny';
    } else if (radius < 16) {
        size = 'small';
    } else if (radius < 32) {
        size = 'medium';
    } else if (radius < 64) {
        size = 'large';
    } else if (radius < 128) {
        size = 'huge';
    } else if (radius < 256) {
        size = 'gigantic';
    }

    var buttonObject = {
        button: b,
        location: location,
        shape: shape,
        sides: sides,
        radius: radius,
        size: size,
        color: color,
        brightness: brightness
    };
   buttonData.push(buttonObject);
}

// These are important functions!
// This is basically creating the features 
// that I will use to generate mappings and learn models
// BE PREPARED FOR CHANGE
// Just now, I am leery of how hard identifying buttons is going to be...
function subtractButtons(buttonA, buttonB) {
    var result = {
        location: {x: buttonA.x - buttonB.x, y: buttonA.y - buttonB.y},
        shape: buttonA.shape == buttonB.shape,
        sides: buttonA.sides - buttonB.sides,
        radius:  buttonA.radius - buttonB.radius, 
        size: allSizes.indexOf(buttonA.size) - allSizes.indexOf(buttonB.size),
        color:  parseInt(buttonA.color.substring(1, 7), 16) - parseInt(buttonB.color.substring(1, 7), 16),
        brightness: buttonA.brightness - buttonB.brightness
    };
    return result;
}

function generateDifferences() {
    for (var i = 0; i < buttonData.length; i++) {
        butttonDifferences[i] = {};
        for (var j = 0; j < buttonData.length; j++) {
            if (j == i) {
                continue;
            }
            butttonDifferences[i][j] = subtractButtons(buttonData[i], buttonData[j]);
        }
    }
}

//  ellipse, rhombus, parralellogram, trapezoid <-- do I want these?
// I think I do want ellipse.  hrm.
// At some point I want non-regular things like 'cross', etc...
// These need to go into shapes.js

function makeButton(paper, location, color, shape, radius, rotation, modFunctions, modIndex) {
    var currentLocation = {}
    if (modFunctions.location) {
        currentLocation.x = location.x + modFunctions.location(modIndex);
        currentLocation.y = location.y + modFunctions.location(modIndex);
    } else {
        currentLocation = location;
    }

    var currentColor;
    if (modFunctions.color) {
        currentColor = modFunctions.color(modIndex);
    } else {
        currentColor = color;
    }

    var currentShape;
    if (modFunctions.shape) {
        currentShape = modFunctions.shape(modIndex);
    } else {
        currentShape = shape;
    }

    var currentRadius = {}
    if (modFunctions.radius) {
        currentRadius.x = radius.x + modFunctions.radius(modIndex);
        currentRadius.y = radius.y + modFunctions.radius(modIndex);
    } else {
        currentRadius = radius;
    }

    var currentRotation;
    if (modFunctions.rotation) {
        currentRotation = rotation + modFunctions.rotation(modIndex);
    } else {
        currentRotation = rotation;
    }

    var button = buttonFunctions[currentShape](paper, currentLocation, currentRadius, currentRotation)
    addButton(button, currentLocation, currentColor, currentShape, currentRadius, rotation);
    button.attr("fill", currentColor);
 }

function makeRandomButton(paper) {
    var minDimension = Math.min(paper.width, paper.height);
    var maxRadius = parseInt(minDimension / 3);
    var location = {x: Math.floor((Math.random() * paper.width)), y: Math.floor((Math.random() * paper.height))};
    var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
    var shapeIndex =  Math.floor(Math.random() * allShapes.length);
    var shape = allShapes[shapeIndex];
    var rotation = Math.random() * 2 * Math.PI;
    var radius = {x: Math.floor(Math.random() * maxRadius) + 1, y: Math.floor(Math.random() * maxRadius) + 1};
    makeButton(paper, location, color, shape, radius, rotation);
 }

function getOffsetAngle(buttonShape) {
    var sides = getSides(buttonShape);
    return ((sides - 2) * Math.PI) / (2 * sides);
}

function getOffset(buttonShape, buttonRadius) {
    // We need a function
    if (buttonShape == 'circle' || buttonShape == 'diamond' || buttonShape == 'octagon') {
        return 2 * buttonRadius.x;
    } else {
        var angle = getOffsetAngle(buttonShape);
        var offset = buttonRadius.y * Math.sin(angle);
        if (getSides(buttonShape) % 2 == 0) {
            return 2 * offset;
        } else {
            return buttonRadius.x + offset;
        }
    }
}

function makeLine(paper, startingPoint, length, spacing, angle, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions) {

        // just for squares, for now...
        var offset = getOffset(buttonShape, buttonRadius)
        console.log(buttonRadius, offset);

        for (var i = 0; i < length; i++) {
            var x = Math.floor(Math.cos(angle) * (i * (spacing + offset))) + startingPoint.x;
            var y = Math.floor(Math.sin(angle) * (i * (spacing + offset))) + startingPoint.y;
            var location = {x: x, y: y};
            
            makeButton(paper, location, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions, i);
    } 
}

function makeRow(paper, startingPoint, length, spacing, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions) {
    // example:  makeRow(paper, {x: 50, y: 100}, 6, 20, '#AA0000', 'circle', {x:50, y:50}, 0, modFunctions);
    makeLine(paper, startingPoint, length, spacing, 0, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions);
}

function makeColumn(paper, startingPoint, length, spacing, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions) {
    // example:  makeColumn(paper, {x: 50, y: 100}, 6, 20, '#AA0000', 'circle', {x:50, y:50}, 0, modFunctions);
    makeLine(paper, startingPoint, length, spacing, Math.PI / 2, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions);
}

function makeColumnGrid(paper, startingPoint, width, height, spacing, offset, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions) {
    // example:  makeOffsetColumnGrid(paper, {x:50, y:50}, 3, 5, {x: 20, y:10}, 2, '#AA0000', 'circle', {x:50, y:50}, 0, modFunctions);
    for (var i = 0; i < width; i++) {
        if (i % 2 == 0) {
            var newStartingPoint = {};
            newStartingPoint.x = startingPoint.x + (i * (spacing.x + buttonRadius.x));
            newStartingPoint.y = startingPoint.y;
        } else {
            var newStartingPoint = {};
            newStartingPoint.x = startingPoint.x + (i * (spacing.x + buttonRadius.x));
            newStartingPoint.y = startingPoint.y + offset;

        }
        makeColumn(paper, newStartingPoint, height, spacing.y, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions);
    }
}

function makeRowGrid(paper, startingPoint, width, height, spacing, offset, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions) {
    // example:  makeOffsetGrid(paper, {x:50, y:50}, 3, 5, {x: 20, y:10}, 2, '#AA0000', 'circle', {x:50, y:50}, 0, modFunctions);
    for (var i = 0; i < height; i++) {
        if (i % 2 == 0) {
            var newStartingPoint = {};
            newStartingPoint.x = startingPoint.x;
            newStartingPoint.y = startingPoint.y + (i * (spacing.y + buttonRadius.y));
        } else {
            var newStartingPoint = {};
            newStartingPoint.x = startingPoint.x + offset;
            newStartingPoint.y = startingPoint.y + (i * (spacing.y + buttonRadius.y));

        }
        makeRow(paper, newStartingPoint, width, spacing.y, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions);
    }
}

function makeCircle(paper, startingPoint, radius, numberOfButtons, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions) {
    // example: makeCircle(paper, {x:400, y:400}, 200, 10, '#AA0000', 'rectangle', {x:10, y:10}, 0, modFunctions);
    var angle = (2 * Math.PI) / numberOfButtons;
    for (var i = 0; i < numberOfButtons; i++) {
            var x = radius * Math.cos(i * angle) + startingPoint.x;
            var y = radius * Math.sin(i * angle) + startingPoint.y;
            var location = {x: x, y: y};
            makeButton(paper, location, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions, i);
    } 
}

function makeRadial(paper, startingPoint, startingRotation, numberOfRadials, length, spacing, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions) {
    // example:  makeRadial(paper, {x:400, y:200}, Math.PI, 5, 5, 55, '#AA0000', 'circle', {x:25, y:25}, 0, modFunctions);
    makeButton(paper, startingPoint, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions, i);
    var angle = (2 * Math.PI) / numberOfRadials;
    for (var i = 0; i < numberOfRadials; i++) {
            var newStartingPoint = {};
            var newAngle = angle * i + startingRotation;
            newStartingPoint.x = Math.floor(Math.cos(newAngle) * (spacing + 2 * buttonRadius.x)) + startingPoint.x;
            newStartingPoint.y = Math.floor(Math.sin(newAngle) * (spacing + 2 * buttonRadius.y)) + startingPoint.y;
            makeLine(paper, newStartingPoint, length - 1, spacing, newAngle, buttonColor, buttonShape, buttonRadius, buttonRotation, modFunctions);
    } 
}


// Simple modification functions
function randomizeColor(index) {
    return '#'+ Math.floor(Math.random() * 16777215).toString(16);
}

function randomizeShape(index) {
    return allShapes[Math.floor(Math.random() * allShapes.length)]
}

function randomizeIntegerParam(index) {
    return Math.floor(Math.random() * 5);
}

function indexedIntegerParam(index) {
    return Math.floor(Math.random() * index * 10);
}

function randomizeRadianParam(index) {
    return Math.random() * Math.PI * 2;
}



function init() {
    // Creates canvas.
    var screensize = {x: 1024, y:  768}
    var paper = Raphael(0, 0, screensize.x, screensize.y);

    // create webAudio code
    var audioContext = new webkitAudioContext();




    // I could, in the future, have one entry for location / radius X and one for Y...
    modFunctions = {
        'location': randomizeIntegerParam,
        'color':  randomizeColor,
        'shape':  null,
        'radius': indexedIntegerParam, 
        'rotation': randomizeRadianParam,
    }

    // Re-doing circles
    //makeCircle(paper, {x:400, y:400}, 200, 10, '#AA0000', 'rectangle', {x:10, y:10}, 0, modFunctions);
    //makeRadial(paper, {x:400, y:200}, Math.PI, 5, 5, 55, '#AA0000', 'circle', {x:25, y:25}, 0, {});

    //makeLine(paper, {x: 100, y: 100}, 6, 20, Math.PI / 4, '#AA0000', 'circle', {x:50, y:50}, 0, {});
    makeColumn(paper, {x: 50, y: 50}, 5, 0, '#AA0000', 'octagon', {x:50, y:50}, 0, {});
    //makeRow(paper, {x: 50, y: 100}, 6, 20, '#AA0000', 'circle', {x:50, y:50}, 0, modFunctions);
    //makeColumnGrid(paper, {x:50, y:50}, 3, 5, {x: 20, y:10}, 20, '#AA0000', 'circle', {x:50, y:50}, 0, {});
    //makeRowGrid(paper, {x:50, y:50}, 3, 5, {x: 0, y:0}, 0, '#AA0000', 'rectangle', {x:50, y:50}, 0, {});



    // Create the differences
    generateDifferences();

    // Hyper-rough faux mapping
    for (var i = 0; i < buttonData.length; i++) {
        var freq = buttonData[i].location.x * 2.1828 + buttonData[i].location.y / 1.618;
        var fr = partial(basicNoteClick, audioContext, freq);

        buttonData[i].button.click(fr);
    }

}

window.onload = init;
</script>
</body>
</html>